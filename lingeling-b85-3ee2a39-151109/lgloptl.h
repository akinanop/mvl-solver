OPT(0,abstime,0,0,1,"print absolute time when reporting");
OPT(0,bate,1,0,1,"basic ATE removal during probing");
OPT(0,batewait,2,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,bca,1,0,2,"enable blocked clause addition (1=weak,2=strong)");
OPT(0,bcaddlimldscale,2,-7,7,"bca added clause limit ld scale");
OPT(0,bcamaxeff,10*M,0,I,"BCA maximum number of steps");
OPT(0,bcaminuse,100,0,I,"min number of literals required to be usable");
OPT(0,bcawait,2,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,bkwdscale,100,1,10000,"bkwd steps vs elm steps in percent");
OPT(0,bkwdroundlim,7,1,I,"bkwd round limit");
OPT(0,bkwdresched,1,0,1,"reschedule variables during backward");
OPT(0,bkwdocclim,100,0,I,"backward occurrence limit");
OPT(0,blkboost,10,1,10000,"initial BCE boost");
OPT(0,blkboostvlim,10*M,0,I,"BCE boost variable limit");
OPT(0,blkclslim,1*M,3,I,"max blocked clause size");
OPT(0,blklarge,1,0,1,"BCE of large clauses");
OPT(0,blkmaxeff,800*M,-1,I,"max effort in BCE (-1=unlimited)");
OPT(0,blkmineff,50*M,0,I,"min effort in BCE");
OPT(0,blkocclim1,100*K,1,I,"one-sided max occ of BCE");
OPT(0,blkocclim,1*M,3,I,"max occ in BCE");
OPT(0,blkocclim2,10*K,2,I,"two-sided max occ of BCE");
OPT(0,blkreleff,100,0,K,"rel effort in BCE");
OPT(0,blkresched,1,0,1,"reschedule tried but failed literals");
OPT(0,blkrtc,0,0,1,"run BCE until completion");
OPT(0,blksmall,1,0,1,"BCE of small clauses");
OPT(0,blksuccessmaxwortc,6,1,I,"BCE success max without run-to-completion");
OPT(0,blksuccessrat,100,1,I,"BCE success ratio");
OPT(0,block,1,0,1,"blocked clause elimination (BCE)");
OPT(0,blockwait,1,0,1,"wait for BVE");
OPT(0,boost,1,0,1,"enable boosting of preprocessors");
OPT(0,bumpseen,1,0,1,"bump seen before minimization");
OPT(0,bumpsort,1,-1,1,"sort before bumping");
OPT(0,bumpsimp,1,0,1,"bump during simplification too");
OPT(0,card,1,0,1,"cardinality constraint reasoning");
OPT(0,cardcut,2,0,2,"1=gomoroy-cuts,2=strengthen");
OPT(0,cardexpam1,3,2,I,"min length of exported at-most-one constraint");
OPT(0,cardglue,0,-1,MAXGLUE,"use lrg red cls too (-1=irr,0=moved,...)");
OPT(0,cardignused,0,0,1,"ignore already used literals in extraction");
OPT(0,cardmaxeff,300*M,-1,I,"max effort for cardmineff reasoning");
OPT(0,cardmaxlen,1000,0,I,"maximal length of cardinality constraints");
OPT(0,cardmineff,2*M,0,I,"min effort for cardmineff reasoning");
OPT(0,cardminlen,3,0,I,"minimal length of (initial) card constraints");
OPT(0,cardocclim1,300,0,I,"one-sided cardinality constraints occ limit");
OPT(0,cardocclim2,15,0,I,"two-sided cardinality constraints occ limit");
OPT(0,cardreleff,5,0,10*K,"rel effort for cardinality reasoning");
OPT(0,cardreschedint,10,1,I,"reschedule variable for card reasoning");
OPT(0,carduse,2,0,3,"use clauses (1=oneside,2=bothsidetoo,3=anyside)");
OPT(0,cardwait,0,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,cce2wait,1,0,I,"wait for ATE to finish before doing ABCE");
OPT(0,cce,3,0,3,"covered clause elimination (1=ate,2=abce,3=acce)");
OPT(0,cceateint,2,1,I,"frequency of only ATE");
OPT(0,cceboost,10,1,1000,"CCE boost");
OPT(0,cceboostdel,3,0,100,"initial CCE boost delay");
OPT(0,cceboostint,5,1,I,"elimination boost interval");
OPT(0,cceboostvlim,10*M,0,I,"CCE boost variable limit");
OPT(0,cce3wait,2,0,I,"wait for ABCE to finish before doing ACCE");
OPT(0,ccemaxround,3,0,I,"cce maximum rounds");
OPT(0,ccemaxeff,I,-1,I,"max effort in covered clause elimination");
OPT(0,ccemineff,30*M,0,I,"min effort in covered clause elimination");
OPT(0,ccereleff,50,0,K,"rel effort in covered clause elimination");
OPT(0,ccertc,0,0,2,"run CCE until completition (1=almost-no-limit)");
OPT(0,ccertcint,15,1,I,"run CCE until completion interval");
OPT(0,ccertcintvlim,2*M,1,I,"run CCE until completion int var limit");
OPT(0,ccesuccessrat,100,1,I,"CCE success ratio");
OPT(0,ccewait,2,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,clim,-1,-1,I,"conflict limit");
OPT(0,compact,0,0,2,"compactify after 'lglsat/lglsimp' (1=UNS,2=SAT)");
OPT(0,deco,1,0,1,"learn decision-only clauses too");
OPT(0,decolim,100,0,I,"decision-only clauses glue limit");
OPT(0,deco1opt,1,0,1,"optimized deco 1");
OPT(0,decompose,1,0,1,"enable decompose");
OPT(0,defragfree,50,10,K,"defragmentation free watches limit");
OPT(0,defragint,10*M,100,I,"defragmentation pushed watches interval");
OPT(0,delmax,10,0,10,"maximum delay");
OPT(0,dlim,-1,-1,I,"decision limit");
OPT(0,druplig,0,0,1,"connect to Druplig library");
OPT(0,drupligcheck,0,0,1,"enable checking of proof by Druplig");
OPT(0,drupligtrace,0,0,1,"enable tracing of proof by Druplig");
OPT(0,drupligtraceorig,0,0,1,"trace original clauses too");
OPT(0,elim,1,0,1,"bounded variable eliminiation (BVE)");
OPT(0,elmaxeff,800*M,-1,I,"max effort in BVE (-1=unlimited)");
OPT(0,elmblk,1,0,1,"enable BCE during BVE");
OPT(0,elmblkwait,1,0,1,"wait for BVE to be completed once");
OPT(0,elmboost,20,1,1000,"elimination boost");
OPT(0,elmboostdel,3,0,100,"initial elimination boost delay");
OPT(0,elmboostint,5,1,I,"elimination boost interval");
OPT(0,elmboostvlim,4*M,1,I,"elimination boost var lim");
OPT(0,elmclslim,1*M,3,I,"max antecendent size in elimination");
OPT(0,elmfull,0,0,1,"no elimination limits");
OPT(0,elmineff,20*M,0,I,"min effort in BVE");
OPT(0,elmlitslim,200,0,I,"one side literals limit for elimination");
OPT(0,elmocclim1,1000,1,I,"one-sided max occ of BVE");
OPT(0,elmocclim,1*M,3,I,"max occurrences in BVE");
OPT(0,elmocclim2,100,2,I,"two-sided max occ of BVE");
OPT(0,elmoccsumforced,0,0,10,"forced occurrence sum");
OPT(0,elmreleff,200,0,10*K,"rel effort in BVE");
OPT(0,elmresched,0,0,7,"reschedule variables (1=else,2=boost,4=full)");
OPT(0,elmroundlim,3,1,I,"variable elimination rounds limit");
OPT(0,elmrtc,0,0,2,"run BVE until completion (1=almost-no-limit)");
OPT(0,elmrtcint,10,1,I,"run BVE until completion interval");
OPT(0,elmrtcintvlim,500*K,1,I,"run BVE until completion int var limit");
OPT(0,elmsuccessmaxwortc,4,1,I,"BVE success max without run-to-completion");
OPT(0,elmsuccessrat,100,1,I,"BVE success ratio");
OPT(0,exitonabort,0,0,1,"exit instead abort after internal error");
OPT(0,factmax,100000,1,I,"maximum factor");
OPT(0,factor,3,0,3,"{cls,occ}lim factors (0=const1,1=ld,2=lin,3=sqr)");
OPT(0,gauss,1,0,1,"enable gaussian elimination");
OPT(0,gaussexptrn,1,0,1,"export trn cls from gaussian elimination");
OPT(0,gaussextrall,1,0,1,"extract all xors (with duplicates)");
OPT(0,gaussmaxeff,50*M,-1,I,"max effort in gaussian elimination");
OPT(0,gaussmaxor,20,2,64,"maximum xor size in gaussian elimination");
OPT(0,gaussmineff,2*M,0,I,"min effort in gaussian elimination");
OPT(0,gaussreleff,2,0,10*K,"rel effort in gaussian elimination");
OPT(0,gausswait,2,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,gluekeep,4,1,I,"keep clauses with this original glue");
OPT(0,gluekeepsize,15,1,I,"but limit them to this size");
OPT(0,gluescale,4,1,5,"glue scaling: 1=ar1,2=ar2,3=sqrt,4=sqrtld,5=ld");
OPT(0,hbrdom,2,0,2,"0=root-impl-tree,1=lca-impl-tree,2=lca-big-dag");
OPT(0,import,1,0,1,"import external indices and map them");
OPT(0,incredcint,1,1,I,"incremental reduce conflict interval");
OPT(0,incredconfslim,0,0,100,"incremental reduce conflict limit");
OPT(0,incsavevisits,0,0,1,"incremental start new visits counter");
OPT(0,inprocessing,1,0,1,"enable inprocessing");
OPT(0,irrlim,1,0,1,"use irredundant clauses as limit for simps");
OPT(0,jwhred,1,0,2,"JWH score based on redundant clauses too (2=only)");
OPT(0,keepmaxglue,1,0,1,"keep maximum glue clauses");
OPT(0,keepmaxglueint,100,1,I,"keep maximum glue clause interval (1 always)");
OPT(0,lhbr,1,0,1, "enable lazy hyber binary reasoning");
OPT(0,lkhd,2,-1,3, "-1=LOCS,0=LIS,1=JWH,2=TREELOOK,3=LENSUM");
OPT(0,locs,0,-1,I,"use local search (-1=always otherwise how often)");
OPT(0,locsbanner,0,0,1,"print version number of LOCS component");
OPT(0,locsclim,1*M,0,(I>>8),"clause limit for local search");
OPT(0,locsboost,2,0,100,"initial local search boost");
OPT(0,locscint,10*K,1,I,"conflict interval for LOCS");
OPT(0,locset,2,0,2,"initialize local search phases (1=prev,2=cur)");
OPT(0,locsexport,1,0,1,"export phases from local search");
OPT(0,locsmaxeff,100000,0,I,"max effort in local search");
OPT(0,locsmineff,1000,0,I,"min effort in local search");
OPT(0,locsred,0,0,4,"apply local search on redundant clauses too");
OPT(0,locsreleff,5,0,100,"rel effort in local search");
OPT(0,locsrtc,0,0,1,"run local search until completion");
OPT(0,locsvared,100,0,1000,"max variable reduction for LOCS");
OPT(0,locswait,2,0,2,"wait for BCE(1) and/or BVE(2)");
OPT(0,maxscaledglue,MAXGLUE,0,MAXGLUE,"maximum scaled glue bound");
OPT(0,maxscorexp,DEFSCOREXP,7,MAXSCOREXP,"maximum score exponent");
OPT(0,memlim,-1,-1,I,"memory limit in MB (-1=no limit)");
OPT(0,minimize,2,0,2,"minimize learned clauses (1=local,2=recursive)");
OPT(0,minlocalgluelim,200,0,I,"glue limit for using local minimization");
OPT(0,minlocalsizelim,3000,0,I,"size limit for using local minimization");
OPT(0,minrecgluelim,100,0,I,"glue limit for using recursive minimization");
OPT(0,minrecsizelim,1000,0,I,"size limit for using recursive minimization");
OPT(0,minscorexp,-DEFSCOREXP,INT_MIN,0,"minimum score exponent");
OPT(0,norestartsatlimlo,85,0,100,"glue/height lower limit for no restart");
OPT(0,move,2,0,2,"move redundant cls (1=only-binary,2=ternary-too)");
OPT(0,otfs,1,0,1,"enable on-the-fly subsumption");
OPT(0,penmax,4,0,16,"maximum penalty");
OPT(0,phase,0,-1,1,"default initial phase (-1=neg,0=JeroslowWang,1=pos)");
OPT(0,phaseluckfactor,200,100,10*K,"min phase luck factor (pos/neg)");
OPT(0,phaselucklim,100,0,1000,"phase luck limit in promille");
OPT(0,phaseluckmaxround,10,0,I,"maximum number of phase luck checks");
OPT(0,phasesave,1,-1,1,"save and use previous phase (-1=reverse)");
OPT(0,plain,0,0,1,"plain mode disables all preprocessing");
OPT(0,plim,-1,-1,I,"propagation limit (thousands)");
OPT(0,poison,1,0,1,"poison optimization for clause minimization");
OPT(0,prbasic,1,0,2,"enable basic probing procedure (1=roots-only)");
OPT(0,prbasicmaxeff,400*M,-1,I,"max effort in basic probing");
OPT(0,prbasicmineff,M,0,I,"min effort in basic probing");
OPT(0,prbasicreleff,50,0,10*K,"rel effort in basic probing");
OPT(0,prbasicroundlim,8,1,I,"basic probing round limit");
OPT(0,prbasicrtc,0,0,1,"run basic probing until completion");
OPT(0,prbrtc,0,0,1,"run all probing until completion");
OPT(0,prbsimple,2,0,3,"simple probing (1=shallow,2=deep,3=touchall)");
OPT(0,prbsimpleboost,10,1,1000,"initial simple probing boost");
OPT(0,prbsimpleliftdepth,2,1,4,"simple probing lifting depth");
OPT(0,prbsimplemaxeff,200*M,-1,I,"max effort in simple probing");
OPT(0,prbsimplemineff,2*M,0,I,"min effort in simple probing");
OPT(0,prbsimplereleff,40,0,10*K,"rel effort in simple probing");
OPT(0,prbsimplertc,0,0,1,"run simple probing until completion");
OPT(0,probe,1,0,1,"enable probing");
OPT(0,promote,1,0,1,"keep clauses with reduced glue longer");
OPT(0,promotegluelim,8,0,MG,"promoted clauses reduced glue limit");
OPT(0,pure,1,0,1,"enable pure literal elimination during BCE");
OPT(0,quatres,1,0,1,"enable quaternay resolution");
OPT(0,quatreswait,2,0,2,"wait with quaternay resolution");
OPT(0,queuedfs,0,0,1,"strict DFS for queue decisions");
OPT(0,queuesort,1,0,1,"sort decision queue by JWH score");
OPT(0,queueunsched,0,0,1,"unschedule and enqueue low score vars");
OPT(0,randec,0,0,1,"enable random decisions");
OPT(0,randecint,1000,2,I/2,"random decision interval");
OPT(0,redcls,1,0,1,"reduce literals in learned clauses");
OPT(0,redclsglue,6,0,I,"upper glue limit for clause reduction");
OPT(0,redclsmaxdec,5,1,I,"max decisions checked per lit");
OPT(0,redclsmaxdepth,10,1,I,"max depth for propagation per lit");
OPT(0,redclsmaxlrg,10,0,I,"max large checked per lit for redcls");
OPT(0,redclsmaxprops,100,0,I,"max props per lit for redcls");
OPT(0,redclsatlimlo,0,0,100,"lower saturation limit for redcls");
OPT(0,redclsatlimhi,100,0,100,"upper saturation limit for redcls");
OPT(0,redclsize,30,0,I,"size limit reducing literals in learned clauses");
OPT(0,redclstype,4,2,4,"type of clauses used for reduction");
OPT(0,reducefixed,0,0,1,"enabled fixed bound on learned clauses");
OPT(0,reduceinc,1000,1,10*M,"reduce limit increment");
OPT(0,reduceinit,50*K,1,100*M,"initial reduce limit");
OPT(0,reduce,1,0,1,"enable clause reduction");
OPT(0,restart,4,0,4,"enable restarting (0=no,1=fixed,2=luby,3=inout,4=glc)");
OPT(0,restartglcint,10,1,I,"glucose restart interval");
OPT(0,restartglclim,105,100,10*K,"gl restart limit (in percent of slow)");
OPT(0,restartinit,0,0,I,"initial restart interval");
OPT(0,restartint,5,1,I,"restart interval");
OPT(0,restartpen,1,0,1,"restart interval penalty");
OPT(0,retirenb,1,0,1,"enabled inactive clause retirement");
OPT(0,retireint,4,0,1000,"retire inactive clauses inprocessing phases count");
OPT(0,retiremin,1,0,I,"minimum glue for retirement");
OPT(0,reusetrail,1,0,1,"reuse trail");
OPT(0,rmincpen,4,0,32,"logarithm of watcher removal penalty");
OPT(0,rstinoutinc,110,1,1000,"restart inner/outer relative increment");
OPT(0,satlimdelay,10*K,0,I,"saturating delay");
OPT(0,scincinc,250,1,10*K,"score increment increment in per mille");
OPT(0,scincincdelta,10,0,10*K,"delta score inc inc in per mille");
OPT(0,scincincincint,100*K,1,I,"score inc inc inc interval");
OPT(0,scincincmin,50,1,10*K,"min score inc inc in per mille");
OPT(0,score,5,0,6,"0=static,1=inc,2=vmtf,3=sum,4=avg,5=evsids,6=vsids256");
OPT(0,scoreshift,24,0,64,"score shift");
OPT(0,scincincmode,1,0,2,"score inc inc mode (0=keep,1=delta,2=avg)");
OPT(0,seed,0,0,I,"random number generator seed");
OPT(0,simpbintinc,100,1,I,"inprocessing binary interval increment");
OPT(0,simpbintinclim,10*K,1,I,"inprocessing bin int inc limit");
OPT(0,simpcintdelay,2000,0,I,"inprocessing conflict delay");
OPT(0,simpcintinc,20*K,10,M,"inprocessing conflict interval increment");
OPT(0,simpcintincdiv,1,0,3,"cintinc reduction: 0=no,1=div1,2=div2,3=heur");
OPT(0,simpcintmaxhard,10*M,-1,I,"hard max conflict interval limit");
OPT(0,simpcintmaxsoft,1*M,-1,I,"soft max conflict interval limit");
OPT(0,simpincdelmaxfact,50,0,1000,"inproc incremental delay max fact");
OPT(0,simpincdelmaxmin,10*K,0,I,"inproc incremental delay max min confs");
OPT(0,simpinitdelay,0,0,I,"initial simplification delay");
OPT(0,simpintsizepen,0,0,1,"penalize interval (positively) by size");
OPT(0,simpen,0,0,24,"logarithmic initial simplification penalty");
OPT(0,simpidiv,3,1,100,"simplification inter delay divisor");
OPT(0,simpiscale,100,1,10000,"relative simplification inter delay scale");
OPT(0,simpitdelay,10,0,1000,"delay inpr by simpitdelay/delta-conf-per-it");
OPT(0,simpitintinc,10,1,I,"inprocessing iteration interval increment");
OPT(0,simpitintinclim,1*K,1,I,"inprocessing its int inc limit");
OPT(0,simplify,2,0,2,"enable simplification");
OPT(0,simprtc,5,1,100,"min var reduction for simplification RTC");
OPT(0,simptintinc,1000,1,I,"inprocessing ternary interval increment");
OPT(0,simptintinclim,10*K,1,I,"inprocessing trn int inc limit");
OPT(0,simpvarchg,100,1,1000, "simp remaining vars percentage change lim");
OPT(0,simpvarlim,100,0,I, "simp remaining vars min limit");
OPT(0,sizemaxpen,5,0,20,"maximum logarithmic size penalty");
OPT(0,sizepen,1*M,1,I,"number of clauses size penalty starting point");
OPT(0,sleeponabort,0,0,I,"sleep this seconds before abort/exit");
OPT(0,smallirr,90,0,100,"max percentage irr lits for BCE and VE");
OPT(0,smallve,1,0,1,"enable small number variables elimination");
OPT(0,smallvevars,FUNVAR,4,FUNVAR, "variables small variable elimination");
OPT(0,smallvewait,0,0,1,"wait with small variable elimination");
OPT(0,sortlits,0,0,1,"sort lits of cls during garbage collection");
OPT(0,subl,9,0,10*K,"try to subsume this many recent learned clauses");
OPT(0,sweep,1,0,1,"enabled SAT sweeping");
OPT(0,sweepboost,10,1,1000,"sweeping boost");
OPT(0,sweepboostdel,4,0,100,"initial sweeping boost delay");
OPT(0,sweepboostint,7,1,I,"sweeping boost interval");
OPT(0,sweepboostvlim,1*M,1,I,"sweeping boost var lim");
OPT(0,sweepfacdec,10,1,100,"decisions limit factor");
OPT(0,sweepforgive,2,0,I,"forgive that many unsucessful rounds");
OPT(0,sweepirr,3,0,3,"irredundant clauses (1=bin,2=trn,3=lrg)");
OPT(0,sweepmaxeff,200*M,-1,I,"max effort in sweeping");
OPT(0,sweepmaxdec,10*K,0,I,"maximum decisions in one sweep implies check");
OPT(0,sweepmaxround,3,-1,I,"maximum rounds in sweeping");
OPT(0,sweepmindec,100,0,I,"mininum decisions in one sweep implies check");
OPT(0,sweepmineff,M,0,I,"min effort in sweeping");
OPT(0,sweepred,3,0,3,"include redundant clauses (1=bin,2=trn,3=lrg)");
OPT(0,sweepreleff,3,0,10*K,"rel effort in sweeping");
OPT(0,sweeprtc,0,0,1,"run sweeping until completion");
OPT(0,sweeprtcint,14,1,I,"run sweeping until completion interval");
OPT(0,sweeprtcintvlim,100*K,1,I,"run sweeping until completion int var lim");
OPT(0,sweepsuccessmaxwortc,6,1,I,"sweeping success max wo run-to-completion");
OPT(0,sweepsuccessrat,1000,1,I,"sweeping success ratio");
OPT(0,sweepwait,2,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,synclsall,1,0,1,"always synchronize all unconsumed clauses");
OPT(0,synclsglue,8,0,I,"clause synchronization glue limit");
OPT(0,synclsint,100,0,1000,"clause synchronization confs interval");
OPT(0,synclslen,40,0,I,"clause synchronization length limit");
OPT(0,syncunint,111111,0,M,"unit synchronization steps interval");
OPT(0,termint,122222,0,M,"termination check interval");
OPT(0,ternres,1,0,1,"generate ternary resolvents");
OPT(0,ternresboost,5,1,100,"initial ternary resolution boost");
OPT(0,ternresrtc,0,0,1,"run ternary resolvents until completion");
OPT(0,ternreswait,2,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,transred,1,0,1,"enable transitive reduction");
OPT(0,transredwait,2,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,trapiflush,0,0,1,"flush API trace after each call");
OPT(0,trdmaxeff,2*M,-1,I,"max effort in transitive reduction");
OPT(0,trdmineff,100*K,0,I,"min effort in transitive reduction");
OPT(0,trdreleff,10,0,10*K,"rel effort in transitive reduction");
OPT(0,treelook,1,0,2,"enable tree-based look-ahead (2=scheduleprobing)");
OPT(0,treelookboost,10,1,100000,"tree-based look-head boost factor");
OPT(0,treelookfull,0,0,1,"do not limit tree-based look-head");
OPT(0,treelookmaxeff,50*M,-1,I,"max effort in tree-look based probing");
OPT(0,treelookmineff,300*K,0,I,"min effort in tree-look based probing");
OPT(0,treelookreleff,2,0,10*K,"rel effort in tree-look based probing");
OPT(0,treelookrtc,0,0,1,"run tree-based look-ahead until completion");
OPT(0,trep,0,0,1,"enable time based interval reporting");
OPT(0,trepint,55555,1,I,"interval for time based reporting");
OPT(0,trnreleff,10,0,K,"rel effort in ternary resolutions");
OPT(0,trnrmaxeff,200*M,-1,I,"max effort in ternary resolutions");
OPT(0,trnrmineff,4*M,0,I,"min effort in ternary resolutions");
OPT(0,unhdatrn,2,0,2,"unhide redundant ternary clauses (1=move,2=force)");
OPT(0,unhdextstamp,1,0,1,"used extended stamping features");
OPT(0,unhdhbr,0,0,1,"enable unhiding hyper binary resolution");
OPT(0,unhdlnpr,3,0,I,"unhide no progress round limit");
OPT(0,unhdmaxeff,20*M,-1,I,"max effort in unhiding");
OPT(0,unhdmineff,100*K,0,I,"min effort in unhiding");
OPT(0,unhdreleff,2,0,10*K,"rel effort in unhiding");
OPT(0,unhdroundlim,20,0,100,"unhide round limit");
OPT(0,unhide,1,0,1,"enable unhiding");
OPT(0,unhidewait,0,0,2,"wait for BCE (1) and/or BVE (2)");
OPT(0,usedtwice,1,0,1,"used twice optimization for clause minimization");
OPT(0,wait,1,0,1,"enable or disable all waiting");
OPT(0,waitmax,4,-1,I,"max simps to wait (-1=nomax)");
OPT(0,witness,1,0,1,"print witness");

OPT('c',check,0,0,3,"check level");
OPT('l',log,-1,-1,5,"log level");
OPT(0,profile,1,0,4,"profile level");
OPT(0,profilelong,0,0,1,"print long profile information");
OPT('v',verbose,0,-1,4,"verbosity level");
